// -*- mode: Java; -*-
package sanka.rest.storage;
import sanka.http.Http;
import sanka.http.HttpClient;
import sanka.http.Query;
import sanka.http.URL;
import sanka.lang.Channel;
import sanka.lang.Mutex;
import sanka.lang.Thread;
import sanka.rest.RestOperation;
import sanka.rest.RestWorker;

class StorageSenderWorker extends RestWorker {
    const WORKER_PATH = "/storage-sender";
    const MAX_QUEUE_SIZE = 1000;

    /**
     * URL of peer StorageReceiver.
     */
    private URL receiverUrl;

    /**
     * Channel for communication between the worker and background thread.
     * This is the queue of storageKeys of the resources that need to be
     * replicated.
     */
    private Channel channel;

    /**
     * Cache of recently posted resources. When the background thread is
     * ready to transmit a resource, it looks for the resource by key in
     * this cache. If the key is not found, then get the current value of
     * the resource directly from storage.
     */
    private byte[][String] storageCache;

    // Replace cacheMutex with thread-safe StorageCache class.
    private Mutex cacheMutex;
    private Thread backgroundThread;

    void onStart() {
        var peerUrl = getConfig(StorageWorker.STORAGE_PEER_PREF);
        if (peerUrl == null) {
            return;
        }
        var path = StorageReceiverWorker.WORKER_PATH;
        if (peerUrl.endsWith("/")) {
            path = path.substring(1);
        }
        this.receiverUrl = new URL(peerUrl + path);
        this.channel = new Channel(MAX_QUEUE_SIZE);
        this.storageCache = new byte[][class String];
        this.cacheMutex = new Mutex();
        this.backgroundThread = new Thread(this);
    }

    void onPost(RestOperation op) {
        if (this.receiverUrl == null) {
            op.setErrorBody("worker disabled");
            return;
        }
        var obj = op.getJsonBody();
        if (obj == null) {
            op.setErrorBody("invalid body");
            return;
        }
        var storageKey = obj.getString(StorageWorker.STORAGE_KEY);
        if (storageKey == null) {
            op.setErrorBody("missing field: " + StorageWorker.STORAGE_KEY);
            return;
        }
        this.cacheMutex.lock();
        this.storageCache[storageKey] = op.getBody();
        this.cacheMutex.unlock();
        this.channel.push(storageKey);
        op.setBody(null);
    }

    /**
     * Run the background thread. Send resources that the worker adds to the
     * queue.
     *
     * TODO. Keep HttpClient open. Send multiple HTTP requests over a single
     * connection. Use a timer to close the connection after sufficient idle
     * time.
     */
    void run() {
        while (true) {
            var storageKey = this.channel.pop();
            if (storageKey == null) {
                break;
            }
            var body = null;
            this.cacheMutex.lock();
            body = this.storageCache[storageKey];
            if (body != null) {
                this.storageCache.remove(storageKey);
            }
            this.cacheMutex.unlock();
            if (body == null) {
                body = getResourceFromStorage(storageKey);
            }
            if (body == null) {
                continue;
            }
            var sender = new HttpClient();
            var ok = sender.send(this.receiverUrl, Http.POST, body);
            if (ok) {
                if (sender.status != Http.OK) {
                    System.println("status code " + sender.status);
                    ok = false;
                }
                sender.close();
            }
            if (ok) {
                postToStorageLog(storageKey);
            } else {
                // TODO Use exponential backoff.
                System.sleep(1000);
            }
        }
    }

    private byte[] getResourceFromStorage(String storageKey) {
        var storageOp = new RestOperation();
        storageOp.method = Http.GET;
        storageOp.path = StorageWorker.WORKER_PATH;
        storageOp.query = new Query();
        storageOp.query.set(StorageWorker.STORAGE_KEY, storageKey);
        sendOperation(storageOp);
        if (!storageOp.success()) {
            return null;
        }
        return storageOp.getBody();
    }

    /**
     * Post a log message indicating that the resource has been replicated,
     * so that if this process crashes, we won't try to replicate the
     * resource on restart.
     */
    private void postToStorageLog(String storageKey) {
        var state = new StorageLogPostState();
        state.operation = StorageLogWorker.REPLICATED_OPERATION;
        state.storageKey = storageKey;
        send(Http.POST, StorageLogWorker.WORKER_PATH, state);
    }
}
