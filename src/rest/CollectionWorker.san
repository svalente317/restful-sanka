// -*- mode: Java; -*-
package sanka.rest;
import sanka.json.JsonElement;
import sanka.json.JsonObject;
import sanka.json.Serializable;
import sanka.http.Query;
import sanka.sqlite3.Database;
import sanka.sqlite3.FieldDesc;
import sanka.sqlite3.JsonTable;

/**
 * CollectionWorker provides the infrastructure to manage a collection of
 * REST resources.
 */
abstract class CollectionWorker extends RestWorker {
    private JsonTable table;

    boolean isCollection() {
        return true;
    }

    void setTableSchema(String tableName, String primaryKey,
                        boolean autoincrement, FieldDesc[] schema) {
        this.table = new JsonTable(
            tableName, primaryKey, autoincrement, schema);
        this.table.createTable(getDatabase());
    }

    Database getDatabase() {
        return Globals.getDatabase();
    }

    /**
     * To create a new resource, post to the collection.
     * To update an existing resource, post to [collection]/[key].
     */
    void onPost(RestOperation op) {
        if (op.key != null) {
            onPostResource(op);
            return;
        }
        var row = op.getJsonBody();
        if (row == null) {
            op.setErrorBody("invalid body");
            return;
        }
        if (this.table.autoincrement) {
            // Do not allow user to specify id.
            // The database will generate a unique id.
            row.remove(this.table.primaryKey);
        } else {
            // The primary key must be non-null.
            // Specific workers may impose other requirements as well.
            if (row.get(this.table.primaryKey) == null) {
                op.setErrorBody("missing field: " + this.table.primaryKey);
                return;
            }
        }
        // Do not allow user to specify generation.
        // Resources are created at generation 1.
        row.setInt("generation", 1);
        op.setJsonBody(row);

        var error = validatePost(op, null);
        if (error != null) {
            op.setErrorBody(error);
            return;
        }
        row = op.getJsonBody();

        var status = this.table.insertRow(getDatabase(), row);
        if (status != 0) {
            op.setErrorBody("post failed: db status " + status);
            return;
        }
        if (this.table.autoincrement) {
            var id = getDatabase().getLastInsertRowId();
            row.setLong(this.table.primaryKey, id);
            op.setJsonBody(row);
        }
    }

    /**
     * Update a resource by its primary key.
     */
    void onPostResource(RestOperation op) {
        var newRow = op.getJsonBody();
        if (newRow == null) {
            op.setErrorBody("invalid body");
            return;
        }

        // Get the current state of the specified resource.
        // This could be implemented using send(RestMethod.GET).
        var sql = "select * from " + this.table.tableName + " where " +
            this.table.primaryKey + " = ?";
        var statement = getDatabase().prepare(sql);
        if (statement == null) {
            op.setErrorBody("database failed with status " +
                getDatabase().getStatus());
            return;
        }
        statement.bindText(1, op.key);
        var oldRow = this.table.nextRowJsonObject(statement);
        statement.finalize();
        if (oldRow == null) {
            op.setErrorBody("resource " + op.key + " not found");
            return;
        }

        // Validate and update the generation.
        var newGeneration = newRow.getAsInt("generation");
        var oldGeneration = oldRow.getAsInt("generation");
        if ((newGeneration != 0) && (newGeneration != oldGeneration)) {
            op.setErrorBody("invalid generation");
            return;
        }
        newRow.setInt("generation", oldGeneration+1);

        // Primary key does not need to be specified in the body, since
        // it is specified in the URL. And it cannot be changed.
        newRow.set(this.table.primaryKey, oldRow.get(this.table.primaryKey));
        op.setJsonBody(newRow);

        var error = validatePost(op, oldRow);
        if (error != null) {
            op.setErrorBody(error);
            return;
        }
        newRow = op.getJsonBody();

        var status = this.table.updateRow(getDatabase(), newRow, null);
        if (status != 0) {
            op.setErrorBody("update failed: db status " + status);
            return;
        }
    }
    
    /**
     * To get the whole collection, get to the collection.
     * To get a single resource, get [collection]/[key].
     */
    void onGet(RestOperation op) {
        if (op.key != null) {
            onGetResource(op);
            return;
        }
        var sql = "select * from " + this.table.tableName;
        var values = null;
        if (op.query != null) {
            var query = getQueryForCollection(op);
            var clause = "";
            var separator = "";
            for (var key, value : query.getMap()) {
                if (isValidQueryKey(key)) {
                    if (values == null) {
                        values = new String[0];
                    }
                    clause = clause + separator + key + "=?";
                    separator = " and ";
                    values.add(value);
                }
            }
            if (values != null) {
                sql = sql + " where " + clause;
            }
        }
        var statement = getDatabase().prepare(sql);
        if (statement == null) {
            op.setErrorBody("query failed with status " +
                getDatabase().getStatus());
            return;
        }
        if (values != null) {
            for (var idx = 0; idx < values.length; idx++) {
                statement.bindText(idx+1, values[idx]);
            }
        }
        var body = "{\"items\":[";
        var comma = "";
        while (true) {
            var obj = this.table.nextRowJsonObject(statement);
            if (obj == null) {
                break;
            }
            body = body + comma + obj.toString();
            comma = ",";
        }
        body = body + "]}";
        op.setRawBody(body.toByteArray());
    }

    /**
     * Get a resource by its primary key.
     */
    void onGetResource(RestOperation op) {
        var sql = "select * from " + this.table.tableName + " where " +
            this.table.primaryKey + " = ?";
        var statement = getDatabase().prepare(sql);
        if (statement == null) {
            op.setErrorBody("database failed with status " +
                getDatabase().getStatus());
            return;
        }
        statement.bindText(1, op.key);
        var row = this.table.nextRowJsonObject(statement);
        statement.finalize();
        if (row == null) {
            op.setErrorBody("resource " + op.key + " not found");
            return;
        }
        op.setJsonBody(row);
    }

    /**
     * TODO. Implement onDelete().
     *
    void onDelete(RestOperation op) {
    */

    /**
     * Validate the given new resource. This may modify the posted data in
     * the operation body. (Normalize fields, etc).
     *
     * If the post request should be aborted, then return an error string
     * to be sent back to the caller.
     *
     * If the post should be continued, then return null.
     */
    String validatePost(RestOperation op, JsonObject oldRow) {
        return null;
    }

    Query getQueryForCollection(RestOperation op) {
        return op.query;
    }

    boolean isValidQueryKey(String key) {
        // TODO verify valid field name
        return true;
    }
}
