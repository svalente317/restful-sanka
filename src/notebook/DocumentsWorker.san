// -*- mode: Java; -*-
package sanka.rest.notebook;
import sanka.http.Http;
import sanka.json.JsonObject;
import sanka.rest.RestOperation;
import sanka.rest.storage.CollectionWorker;

serializable class DocumentState {
    String id;
    int userId;
    String filename;
    long lastUpdate;
}

class DocumentsWorker extends CollectionWorker {
    const WORKER_PATH = "/documents";

    // As long as the user keeps saving every five minutes, it all remains
    // a single session.
    const SESSION_TIME = 5 * 60 * 1000;

    const DOCUMENT_ROOT = "/tmp/";

    DocumentsWorker() {
        setPrimaryKeyField("id");
        setPrimaryKeyGenerationPrefix("d");
    }

    /**
     * DocumentsWorker ignores all user input. It simply decides when to
     * generate new filenames, and when to overwrite existing files.
     */
    String validatePost(RestOperation op, JsonObject oldRow) {
        var state = new DocumentState();
        op.parseBody(state);
        state.userId = op.userId;
        state.filename = null;
        state.lastUpdate = System.currentTimeMillis();
        if (oldRow != null) {
            var current = new DocumentState();
            current.fromJson(oldRow);
            if (current.userId == op.userId && current.filename != null &&
                current.lastUpdate + SESSION_TIME >= state.lastUpdate) {
                // The user is saving the document in the same "session" as
                // the previous save. Overwrite the previous version.
                // The new version will represent this session.
                state.filename = current.filename;
            } else {
                if (current.filename != null) {
                    postDocumentHistory(current);
                }
                state.filename = generateFilename();
            }
        }
        op.setBody(state);
        return null;
    }

    private void postDocumentHistory(DocumentState state) {
        var history = new DocumentHistoryState();
        history.documentId = state.id;
        history.userId = state.userId;
        history.filename = state.filename;
        history.lastUpdate = state.lastUpdate;
        send(Http.POST, DocumentHistoryWorker.WORKER_PATH, history);
    }

    private String generateFilename() {
        return DOCUMENT_ROOT + System.currentTimeMillis();
    }

    // TODO onDelete(): postDocumentHistory() if necessary
}
